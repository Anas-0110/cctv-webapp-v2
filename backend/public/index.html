<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CCTV Layout</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: black;
    }
    #container {
      width: 100%;
      height: 100%;
      position: relative;
      background: black;
    }

    #layoutWrapper {
      position: absolute;
      inset: 0;
      cursor: default;
    }
    #layout {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      transform-origin: top left;
    }

    #markersLayer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .marker {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      position: absolute;
      cursor: pointer;
      z-index: 5;
      box-shadow: 0 0 0 2px rgba(0,0,0,.25);
      pointer-events: auto;
    }
    .red { background: red; }
    /* Cone-shaped yellow marker (triangle) */
/* Trapezoid-shaped yellow marker */
.marker.yellow {
  width: 40px;    /* bottom width (default) */
  height: 40px;   /* height (default) */
  background: rgba(255, 255, 0, 0.3);
  border-radius: 0;
  position: absolute;
  cursor: pointer;
  z-index: 6;
  pointer-events: auto;
  clip-path: polygon(10% 0%, 90% 0%, 100% 100%, 0% 100%);
  transform-origin: 50% 100%;
}

    .marker-label {
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 2px 6px;
      font-size: 12px;
      border-radius: 4px;
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
    }
    .marker:hover .marker-label {
      opacity: 1;
    }

    #backButton, #addMarkerButton {
      position: absolute;
      top: 20px;
      padding: 10px 15px;
      font-size: 16px;
      background: white;
      border: none;
      cursor: pointer;
      z-index: 10;
      border-radius: 8px;
    }
    #backButton { left: 20px; display: none; }
    #addMarkerButton { right: 20px; }

    #imageView {
      display: none;
      position: absolute;
      inset: 0;
      overflow: hidden;
      z-index: 3;
      background: black;
    }
    #imageView img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="layoutWrapper">
      <img id="layout" src="floorplan.jpg" alt="Layout">
    </div>

    <div id="markersLayer"></div>

    <div id="imageView">
      <img id="camImage" src="" alt="">
    </div>

    <button id="backButton">Back</button>
    <button id="addMarkerButton">+ Add Marker</button>
  </div>

  <script>
    const container = document.getElementById("container");
    const layout = document.getElementById("layout");
    const layoutWrapper = document.getElementById("layoutWrapper");
    const markersLayer = document.getElementById("markersLayer");
    const imageView = document.getElementById("imageView");
    const camImage = document.getElementById("camImage");
    const backButton = document.getElementById("backButton");
    const addMarkerButton = document.getElementById("addMarkerButton");

    let scale = 1;
    const minScale = 1;
    const maxScale = 5;
    let panX = 0, panY = 0;
    let currentRedMarker = null;
    let currentView = "floorplan"; // "floorplan", "red", "yellow"

    function getRect(el) { return el.getBoundingClientRect(); }
    function containerRect() { return getRect(container); }
    function layoutRect() { return getRect(layout); }

    function positionMarker(marker, fx, fy) {
      const lrect = layoutRect();
      const x = fx * lrect.width + lrect.left - containerRect().left;
      const y = fy * lrect.height + lrect.top - containerRect().top;
      marker.style.left = `${x - marker.offsetWidth/2}px`;
      marker.style.top = `${y - marker.offsetHeight/2}px`;
    }

function normalizeYellowList(list) {
  return (list || []).map(item => {
    if (typeof item === "string") {
      return { image: item, fx: 0.5, fy: 0.6, width: 20, height: 40, rotation: 0, type: "cone" };
    }
    return {
      image: item.image ?? "cam2.jpg",
      fx: item.fx ?? 0.5,
      fy: item.fy ?? 0.6,
      width: item.width ?? 20,
      height: item.height ?? 40,
      rotation: item.rotation ?? 0,
      type: item.type ?? "cone", // üî• default cone if not saved
    };
  });
}

    function positionYellowDom(yEl, fx, fy) {
      const rect = imageView.getBoundingClientRect();
      yEl.style.left = `${fx * rect.width}px`;
      yEl.style.top  = `${fy * rect.height}px`;
    }

function makeDraggableRed(marker) {
  let dragging = false, offsetX = 0, offsetY = 0;

  marker.addEventListener("mousedown", (e) => {
    if (e.button !== 0) return;
    dragging = true;
    const rect = marker.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;
    e.preventDefault();
  });

  document.addEventListener("mousemove", (e) => {
    if (!dragging) return;

    const lrect = layout.getBoundingClientRect();
    let fx = (e.clientX - lrect.left) / lrect.width;
    let fy = (e.clientY - lrect.top) / lrect.height;

    fx = Math.min(Math.max(fx, 0), 1);
    fy = Math.min(Math.max(fy, 0), 1);

    marker.dataset.fx = fx;
    marker.dataset.fy = fy;
    positionMarker(marker, fx, fy);
  });

  document.addEventListener("mouseup", () => {
    if (!dragging) return;
    dragging = false;
    saveMarkers(); // <-- persist the new position to server
  });
}

// Apply to all yellow markers
document.querySelectorAll(".marker.yellow").forEach((marker) => {
  makeDraggableRed(marker);
});

// ---- Enable rotation for yellow cone markers ----
function enableYellowRotation(yEl) {
  let isRotating = false;
  let centerX = 0, centerY = 0;
  let startAngle = 0;
  let startRotation = 0;

  yEl.addEventListener("mousedown", e => {
    if (!e.shiftKey) return; // hold SHIFT to rotate
    e.preventDefault();
    const rect = yEl.getBoundingClientRect();
    centerX = rect.left + rect.width / 2;
    centerY = rect.top + rect.height / 2;

    const dx = e.clientX - centerX;
    const dy = e.clientY - centerY;
    startAngle = Math.atan2(dy, dx);
    startRotation = Number(yEl.dataset.rotation || 0);
    isRotating = true;
  });

  window.addEventListener("mousemove", e => {
    if (!isRotating) return;
    const dx = e.clientX - centerX;
    const dy = e.clientY - centerY;
    const angle = Math.atan2(dy, dx);
    const deg = startRotation + (angle - startAngle) * (180 / Math.PI);

    yEl.style.transform = `rotate(${deg}deg)`;
    yEl.dataset.rotation = deg;

    // üî• Update rotation in currentRedMarker yellow list
    if (currentRedMarker) {
      const list = normalizeYellowList(JSON.parse(currentRedMarker.dataset.yellow || "[]"));
      const idx = parseInt(yEl.dataset.index, 10);
      if (!isNaN(idx) && list[idx]) {
        list[idx].rotation = deg;
        currentRedMarker.dataset.yellow = JSON.stringify(list);
      }
    }
  });

  window.addEventListener("mouseup", () => {
    if (isRotating) {
      isRotating = false;
      saveMarkers(); // save new rotation to backend
    }
  });
}

// Apply to all yellow markers
document.querySelectorAll(".marker.yellow").forEach((marker) => {
  makeRotatable(marker);
});

// ---- Right-click menu for cones ----
function addContextMenu(marker) {
  marker.addEventListener("contextmenu", (e) => {
    e.preventDefault(); // disable browser context menu
  });

  let clickCount = 0;
  marker.addEventListener("mousedown", (e) => {
    if (e.button === 2) { // Right-click
      clickCount++;
      if (clickCount === 2) {
        clickCount = 0;
        showMenu(e, marker);
      }
      setTimeout(() => (clickCount = 0), 400); // reset double click timer
    }
  });
}

function showMenu(e, marker) {
  // remove old menu if exists
  const oldMenu = document.querySelector(".context-menu");
  if (oldMenu) oldMenu.remove();

  const menu = document.createElement("div");
  menu.className = "context-menu";
  menu.style.position = "absolute";
  menu.style.left = e.pageX + "px";
  menu.style.top = e.pageY + "px";
  menu.style.background = "#fff";
  menu.style.border = "1px solid #ccc";
  menu.style.padding = "5px";
  menu.style.zIndex = 1000;

  const deleteBtn = document.createElement("div");
  deleteBtn.innerText = "üóëÔ∏è Delete Cone";
  deleteBtn.style.cursor = "pointer";
  deleteBtn.onclick = () => {
    marker.remove();
    menu.remove();
  };

  const resizeBtn = document.createElement("div");
  resizeBtn.innerText = "üìè Resize Cone";
  resizeBtn.style.cursor = "pointer";
  resizeBtn.onclick = () => {
    let newSize = prompt("Enter new size (e.g., 60 for bigger, 30 for smaller):", "40");
    if (newSize) {
      marker.style.borderLeft = `${newSize}px solid transparent`;
      marker.style.borderRight = `${newSize}px solid transparent`;
      marker.style.borderBottom = `${newSize * 1.5}px solid yellow`;
    }
    menu.remove();
  };

  menu.appendChild(deleteBtn);
  menu.appendChild(resizeBtn);
  document.body.appendChild(menu);

  // remove menu on click outside
  window.addEventListener(
    "click",
    () => {
      if (menu) menu.remove();
    },
    { once: true }
  );
}

// Apply to all yellow markers
document.querySelectorAll(".marker.yellow").forEach((marker) => {
  addContextMenu(marker);
});

    function createRedMarker(fx=0.5, fy=0.5, image="cam1.jpg", yellowImages=[]) {
      const m = document.createElement("div");
      m.className = "marker red";
      m.dataset.fx = fx;
      m.dataset.fy = fy;
      m.dataset.image = image;
      m.dataset.yellow = JSON.stringify(yellowImages);
      markersLayer.appendChild(m);
      positionMarker(m, fx, fy);
      makeDraggableRed(m);

      const label = document.createElement("span");
      label.className = "marker-label";
      label.textContent = image.replace(/\.[^/.]+$/, ""); 
      m.appendChild(label);

      m.addEventListener("click", () => {
        currentRedMarker = m;
        currentView = "red";
        layout.style.visibility = "hidden";
        Array.from(markersLayer.children).forEach(x => x.style.display = "none");
        imageView.style.display = "block";
        camImage.src = m.dataset.image;
        backButton.style.display = "block";
        addMarkerButton.textContent = "+ Add Yellow Marker";

        document.querySelectorAll("#imageView .marker.yellow").forEach(y => y.remove());
        const yellowList = normalizeYellowList(JSON.parse(m.dataset.yellow || "[]"));
        m.dataset.yellow = JSON.stringify(yellowList);
        yellowList.forEach((obj, i) => createYellowMarker(obj, i));
      });
      return m;
    }

function makeYellowDraggable(yEl) {
  let dragging = false, moved = false, offsetX = 0, offsetY = 0;

  yEl.addEventListener("mousedown", (e) => {
    if (e.button !== 0) return; // left click only
    dragging = true;
    moved = false;
    const rect = imageView.getBoundingClientRect();
    offsetX = e.clientX - (rect.left + parseFloat(yEl.style.left || 0));
    offsetY = e.clientY - (rect.top  + parseFloat(yEl.style.top  || 0));
    e.preventDefault();
  });

  document.addEventListener("mousemove", (e) => {
    if (!dragging) return;
    const rect = imageView.getBoundingClientRect();
    let px = e.clientX - rect.left - offsetX;
    let py = e.clientY - rect.top  - offsetY;
    px = Math.max(0, Math.min(px, rect.width - yEl.offsetWidth));
    py = Math.max(0, Math.min(py, rect.height - yEl.offsetHeight));
    yEl.style.left = `${px}px`;
    yEl.style.top  = `${py}px`;
    yEl.dataset.fx = px / rect.width;
    yEl.dataset.fy = py / rect.height;
    moved = true;
  });

  document.addEventListener("mouseup", () => {
    if (!dragging) return;
    dragging = false;
    if (moved && currentRedMarker) {
      const list = normalizeYellowList(JSON.parse(currentRedMarker.dataset.yellow || "[]"));
      const idx = parseInt(yEl.dataset.index, 10);
      if (!isNaN(idx) && list[idx]) {
        list[idx].fx = parseFloat(yEl.dataset.fx);
        list[idx].fy = parseFloat(yEl.dataset.fy);
        currentRedMarker.dataset.yellow = JSON.stringify(list);
        saveMarkers();
      }
    }
  });
}

function applyConeStyle(yEl, bottomWidth, height, rot) {
  yEl.dataset.width = bottomWidth;
  yEl.dataset.height = height;
  yEl.dataset.rotation = rot;

  yEl.style.width = `${bottomWidth}px`;
  yEl.style.height = `${height}px`;
  yEl.style.background = "rgba(255, 255, 0, 0.3)";
  yEl.style.clipPath = "polygon(35% 0%, 65% 0%, 100% 100%, 0% 100%)";
  yEl.style.transformOrigin = "50% 100%";
  yEl.style.transform = `rotate(${rot}deg)`;
  yEl.style.border = "none"; // remove old triangle borders
}

    function createYellowMarker(obj, index) {
  const y = document.createElement("div");
  y.className = "marker yellow";
  y.dataset.index = index;
  y.dataset.image = obj.image;
  y.dataset.fx = obj.fx;
  y.dataset.fy = obj.fy;
  y.dataset.type = obj.type || "cone"; // üî• save type
  imageView.appendChild(y);

  const label = document.createElement("span");
  label.className = "marker-label";
  label.textContent = obj.image.replace(/\.[^/.]+$/, "");
  y.appendChild(label);

  if (y.dataset.type === "cone") {
    const w = obj.width || 20;
    const h = obj.height || 40;
    const rot = obj.rotation || 0;
    applyConeStyle(y, w, h, rot);
    enableYellowRotation(y);
  } else if (y.dataset.type === "circle") {
  const size = obj.width || 50; // use width as diameter
  y.style.width = `${size}px`;
  y.style.height = `${size}px`;
  y.style.borderRadius = "50%";

  // üî• Reset any leftover cone styles
  y.style.border = "none";
  y.style.borderLeft = "none";
  y.style.borderRight = "none";
  y.style.borderBottom = "none";

  // üîµ Apply full blue fill
  y.style.background = "rgba(0, 0, 255, 0.1)";
  y.style.transform = "translate(-50%, -50%)";

  // üî• Store size in dataset so saveMarkers can pick it up
  y.dataset.width = size;
  y.dataset.height = size;
}
  positionYellowDom(y, obj.fx, obj.fy);

  makeYellowDraggable(y);
  return y;
}


 addMarkerButton.addEventListener("click", () => {
  const PASSWORD = "anas"; // set your password

  // Ask for password first
  const input = prompt("Enter password to add marker:");
  if (input !== PASSWORD) {
    alert("Incorrect password! Access denied.");
    return; // stop execution if wrong
  }

  // --- Existing logic below stays the same ---
  if (!currentRedMarker) {
    const defaultName = "cam" + (markersLayer.children.length + 1) + ".jpg";
    const imgName = prompt("Enter main image filename for this CCTV:", defaultName);
    if (!imgName) return; // cancel pressed
    createRedMarker(0.5, 0.5, imgName, []);
    saveMarkers();
  } else {
    const list = normalizeYellowList(JSON.parse(currentRedMarker.dataset.yellow || "[]"));
    const defaultYellow = "cam" + (list.length + 2) + ".jpg";
    const yimg = prompt("Enter yellow camera image filename:", defaultYellow);
    if (!yimg) return; // cancel pressed
    const fovType = prompt("Enter FOV type: 'cone' or 'circle'", "cone");
    if (!fovType) return; // cancel pressed
    const newObj = { image: yimg, fx: 0.5, fy: 0.6, type: fovType };
    list.push(newObj);
    currentRedMarker.dataset.yellow = JSON.stringify(list);
    createYellowMarker(newObj, list.length - 1);
    saveMarkers();
  }
});

    backButton.addEventListener("click", () => {
      if (currentView === "yellow") {
        currentView = "red";
        camImage.src = currentRedMarker.dataset.image;
        const yellowList = normalizeYellowList(JSON.parse(currentRedMarker.dataset.yellow || "[]"));
        document.querySelectorAll("#imageView .marker.yellow").forEach(y => y.remove());
        yellowList.forEach((obj, i) => createYellowMarker(obj, i));
        addMarkerButton.textContent = "+ Add Yellow Marker";
      } else if (currentView === "red") {
        currentView = "floorplan";
        imageView.style.display = "none";
        layout.style.visibility = "visible";
        Array.from(markersLayer.children).forEach(x => x.style.display = "block");
        backButton.style.display = "none";
        addMarkerButton.textContent = "+ Add Marker";
        currentRedMarker = null;
        updateAllMarkers();
      }
    });

    function updateAllMarkers() {
      markersLayer.querySelectorAll(".red").forEach(m => {
        positionMarker(m, parseFloat(m.dataset.fx), parseFloat(m.dataset.fy));
      });
      if (imageView.style.display === "block") {
        document.querySelectorAll("#imageView .marker.yellow").forEach(y => {
          const fx = parseFloat(y.dataset.fx || "0.5");
          const fy = parseFloat(y.dataset.fy || "0.6");
          positionYellowDom(y, fx, fy);
        });
      }
    }
    window.addEventListener("resize", updateAllMarkers);
    if (layout.complete) updateAllMarkers();
    else layout.addEventListener("load", updateAllMarkers);

    // -------- Double-click draggable floorplan --------
    let isPanning = false, startX = 0, startY = 0;
    let draggableEnabled = false;

    layoutWrapper.addEventListener("dblclick", () => {
      draggableEnabled = !draggableEnabled;
      layoutWrapper.style.cursor = draggableEnabled ? "grab" : "default";
    });

    layoutWrapper.addEventListener("mousedown", e => {
      if (currentView !== "floorplan") return;
      if (!draggableEnabled) return;
      if (scale === 1) return;
      isPanning = true;
      startX = e.clientX - panX;
      startY = e.clientY - panY;
      layoutWrapper.style.cursor = "grabbing";
    });

    document.addEventListener("mousemove", e => {
      if (!isPanning) return;

      let newPanX = e.clientX - startX;
      let newPanY = e.clientY - startY;

      const rect = container.getBoundingClientRect();
      const imgWidth = layout.offsetWidth * scale;
      const imgHeight = layout.offsetHeight * scale;

      if (imgWidth <= rect.width) newPanX = 0;
      else newPanX = Math.min(0, Math.max(rect.width - imgWidth, newPanX));

      if (imgHeight <= rect.height) newPanY = 0;
      else newPanY = Math.min(0, Math.max(rect.height - imgHeight, newPanY));

      panX = newPanX;
      panY = newPanY;
      layout.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
      updateAllMarkers();
    });

    document.addEventListener("mouseup", () => {
      if (!isPanning) return;
      isPanning = false;
      if (draggableEnabled) layoutWrapper.style.cursor = "grab";
    });

    // -------- Cursor-centered zoom --------
    container.addEventListener("wheel", e => {
      if (imageView.style.display === "block") return;
      e.preventDefault();

      const rect = layout.getBoundingClientRect();
      const offsetX = e.clientX - rect.left;
      const offsetY = e.clientY - rect.top;
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      const newScale = Math.min(maxScale, Math.max(minScale, scale * zoomFactor));
      if (newScale !== scale) {
        panX -= (offsetX / scale - offsetX / newScale);
        panY -= (offsetY / scale - offsetY / newScale);
        scale = newScale;

        const imgWidth = layout.offsetWidth * scale;
        const imgHeight = layout.offsetHeight * scale;
        const containerRectObj = container.getBoundingClientRect();

        if (imgWidth <= containerRectObj.width) panX = 0;
        else panX = Math.min(0, Math.max(containerRectObj.width - imgWidth, panX));

        if (imgHeight <= containerRectObj.height) panY = 0;
        else panY = Math.min(0, Math.max(containerRectObj.height - imgHeight, panY));

        layout.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        updateAllMarkers();
      }
    }, {passive:false});


    /* === ADD-ON: Double-click Rename Feature (fixed single-click open) === */
(function enableSmartDoubleClickRename() {
  function renameRed(m) {
    const labelEl = m.querySelector(".marker-label");
    const oldName = (labelEl && labelEl.textContent) || (m.dataset.image || "").replace(/\.[^/.]+$/, "");
    const newName = prompt("Rename this red marker:", oldName);
    if (newName && newName.trim() !== "") {
      const trimmed = newName.trim();
      if (labelEl) labelEl.textContent = trimmed;
      m.dataset.image = trimmed + ".jpg";
      if (currentView === "red" && currentRedMarker === m) camImage.src = m.dataset.image;
      saveMarkers();
    }
  }

  function renameYellow(y) {
    const labelEl = y.querySelector(".marker-label");
    const oldName = (labelEl && labelEl.textContent) || (y.dataset.image || "").replace(/\.[^/.]+$/, "");
    const newName = prompt("Rename this yellow marker:", oldName);
    if (newName && newName.trim() !== "") {
      const trimmed = newName.trim();
      if (labelEl) labelEl.textContent = trimmed;
      y.dataset.image = trimmed + ".jpg";
      if (currentRedMarker) {
        const list = normalizeYellowList(JSON.parse(currentRedMarker.dataset.yellow || "[]"));
        const idx = parseInt(y.dataset.index, 10);
        if (!isNaN(idx) && list[idx]) {
          list[idx].image = y.dataset.image;
          currentRedMarker.dataset.yellow = JSON.stringify(list);
        }
        if (currentView === "yellow") camImage.src = y.dataset.image;
        saveMarkers();
      }
    }
  }

  // ---- Handle RED markers ----
  markersLayer.addEventListener("click", (e) => {
    const m = e.target.closest(".marker.red");
    if (!m) return;

    if (e.detail === 2) { // double click
      clearTimeout(m._clickTimer);
      e.stopImmediatePropagation(); // prevent original single-click from firing
      renameRed(m);
    } else if (e.detail === 1) { // single click
      clearTimeout(m._clickTimer);
      m._clickTimer = setTimeout(() => {
        // Let the original single-click handler run naturally
        m.dispatchEvent(new Event("singleclick"));
      }, 200);
    }
  }, true);

  // ---- Handle YELLOW markers ----
  imageView.addEventListener("click", (e) => {
    const y = e.target.closest(".marker.yellow");
    if (!y) return;

    if (e.detail === 2) {
      clearTimeout(y._clickTimer);
      e.stopImmediatePropagation();
      renameYellow(y);
    } else if (e.detail === 1) {
      clearTimeout(y._clickTimer);
      y._clickTimer = setTimeout(() => {
        y.dispatchEvent(new Event("singleclick"));
      }, 200);
    }
    /* === ADD-ON: Double Right-Click Rename/Delete Menu === */
    (function enableDoubleRightClickMenu() {
      let lastRightClick = 0;
      let rightClickTarget = null;

      document.addEventListener("contextmenu", (e) => {
        const marker = e.target.closest(".marker");
        if (!marker) return;

        const now = Date.now();

        if (now - lastRightClick < 400 && rightClickTarget === marker) {
          // --- Detected double right-click ---
          e.preventDefault();
          e.stopPropagation();

          const choice = prompt("Type 'r' to Rename or 'd' to Delete this marker:", "r");
          if (!choice) return;

          if (choice.toLowerCase() === "r") {
            // --- Rename logic ---
            const labelEl = marker.querySelector(".marker-label");
            const oldName = (labelEl && labelEl.textContent) || (marker.dataset.image || "").replace(/\.[^/.]+$/, "");
            const newName = prompt("Rename marker:", oldName);
            if (newName && newName.trim() !== "") {
              const trimmed = newName.trim();
              if (labelEl) labelEl.textContent = trimmed;
              marker.dataset.image = trimmed + ".jpg";

              if (marker.classList.contains("red")) {
                if (currentView === "red" && currentRedMarker === marker) {
                  camImage.src = marker.dataset.image;
                }
              } else if (marker.classList.contains("yellow") && currentRedMarker) {
                const list = normalizeYellowList(JSON.parse(currentRedMarker.dataset.yellow || "[]"));
                const idx = parseInt(marker.dataset.index, 10);
                if (!isNaN(idx) && list[idx]) {
                  list[idx].image = marker.dataset.image;
                  currentRedMarker.dataset.yellow = JSON.stringify(list);
                  if (currentView === "yellow") camImage.src = marker.dataset.image;
                }
              }
              saveMarkers();
            }
          } else if (choice.toLowerCase() === "d") {
            // --- Delete manually ---
            if (confirm("Delete this marker?")) {
              marker.remove();
              saveMarkers();
            }
          }
        }

        // Update tracking (but prevent single right-click action)
        lastRightClick = now;
        rightClickTarget = marker;

        // Prevent the original single right-click delete from firing
        e.preventDefault();
        e.stopPropagation();
      }, true);
    })();
    }, true);
  })();
  (function() {
  let lastRightClick = 0;

function handleDoubleRightClick(target, isRed) {
  if (isRed) {
    // RED marker logic
    const action = prompt("Type 'r' to Rename or 'd' to Delete this red marker:", "r");
    if (!action) return;

    if (action.toLowerCase() === "r") {
      const newName = prompt("Enter new name:", target.dataset.image);
      if (newName) {
        target.dataset.image = newName;
        const labelEl = target.querySelector(".marker-label");
        if (labelEl) labelEl.textContent = newName.replace(/\.[^/.]+$/, "");
        if (currentView === "red" && currentRedMarker === target) camImage.src = target.dataset.image;
        saveMarkers();
      }
    } else if (action.toLowerCase() === "d") {
      if (confirm("Delete this marker?")) {
        target.remove();
        saveMarkers();
      }
    }
  } else {
    // YELLOW marker logic
    const action = prompt("Type 'r' to Rename, 's' to Resize, or 'd' to Delete this yellow marker:", "r");
    const idx = parseInt(target.dataset.index, 10);
    if (isNaN(idx) || !currentRedMarker) return;

    const list = normalizeYellowList(JSON.parse(currentRedMarker.dataset.yellow || "[]"));

    if (action.toLowerCase() === "r") {
      const newName = prompt("Enter new name:", target.dataset.image);
      if (newName) {
        target.dataset.image = newName;
        const labelEl = target.querySelector(".marker-label");
        if (labelEl) labelEl.textContent = newName.replace(/\.[^/.]+$/, "");
        list[idx].image = target.dataset.image;
        currentRedMarker.dataset.yellow = JSON.stringify(list);
        saveMarkers();
      }
    } else if (action.toLowerCase() === "s") {
    // Resize logic
    const idx = parseInt(target.dataset.index, 10);
    if (target.dataset.type === "cone") {
        const newHeight = parseInt(prompt("Enter new cone height:", target.dataset.height || "40"));
        const newWidth  = parseInt(prompt("Enter new cone width:",  target.dataset.width  || "20"));
        const w = !isNaN(newWidth)  && newWidth  > 0 ? newWidth  : Number(target.dataset.width)  || 20;
        const h = !isNaN(newHeight) && newHeight > 0 ? newHeight : Number(target.dataset.height) || 40;
        const rot = Number(target.dataset.rotation) || 0;
        applyConeStyle(target, w, h, rot);
        if (!isNaN(idx) && currentRedMarker) {
            const list = normalizeYellowList(JSON.parse(currentRedMarker.dataset.yellow || "[]"));
            list[idx].width = w;
            list[idx].height = h;
            currentRedMarker.dataset.yellow = JSON.stringify(list);
        }
    } else if (target.dataset.type === "circle") {
        // Circle resize - ask for diameter
        const newDiameter = parseInt(prompt("Enter new circle diameter:", target.dataset.width || "50"));
        const size = !isNaN(newDiameter) && newDiameter > 0 ? newDiameter : Number(target.dataset.width) || 50;
        target.style.width = `${size}px`;
        target.style.height = `${size}px`;
        target.style.borderRadius = "50%";
        target.style.background = "rgba(0, 0, 255, 0.7)";
        target.dataset.width = size;
        target.dataset.height = size;

        // üî• Save to currentRedMarker yellow list
        if (!isNaN(idx) && currentRedMarker) {
            const list = normalizeYellowList(JSON.parse(currentRedMarker.dataset.yellow || "[]"));
            list[idx].width = size;
            list[idx].height = size;
            currentRedMarker.dataset.yellow = JSON.stringify(list);
        }
    }

    if (currentRedMarker) saveMarkers(); // persist changes
}
 else if (action.toLowerCase() === "d") {
      list.splice(idx, 1);
      currentRedMarker.dataset.yellow = JSON.stringify(list);
      target.remove();
      // Reindex remaining yellow markers
      document.querySelectorAll("#imageView .marker.yellow").forEach((y, i) => y.dataset.index = i);
      saveMarkers();
    }
  }
}

  // Global right-click handler
document.addEventListener("contextmenu", (e) => {
  const target = e.target.closest(".marker.red, .marker.yellow");
  if (!target) return; // not a marker

  e.preventDefault(); // stop browser menu
  e.stopPropagation(); // stop the draggable right-click from running

  const now = Date.now();
  if (now - lastRightClick < 400) {
    // double right click
    handleDoubleRightClick(target, target.classList.contains("red"));
  }
  lastRightClick = now;
}, true); // <-- capture mode
})();
// === Fetch saved markers from backend instead of localStorage ===
const API = (p) => `${location.origin}${p}`;

async function loadMarkersFromServer() {
  try {
    const res = await fetch(API("/api/markers"), { cache: "no-store" });
    if (!res.ok) throw new Error(`GET /api/markers failed: ${res.status} ${res.statusText}`);
    const data = await res.json();
    console.log("üì• Loaded markers from server:", data);

    // Clear any existing red markers before re-rendering
    markersLayer.innerHTML = "";

    // Defensive: accept both raw docs and minimal objects
    if (!Array.isArray(data)) return;
    data.forEach((doc) => {
      const fx = Number(doc.fx) || 0.5;
      const fy = Number(doc.fy) || 0.5;
      const image = doc.image || "cam1.jpg";
      const yellow = Array.isArray(doc.yellow) ? doc.yellow : [];
      createRedMarker(fx, fy, image, yellow);
    });
  } catch (err) {
    console.error("‚ùå Failed to load markers from server:", err);
  }
}

async function saveMarkersToServer() {
  // Build the payload exactly as your schema expects
  const payload = [];
  markersLayer.querySelectorAll(".red").forEach((m) => {
    const yellowList = normalizeYellowList(JSON.parse(m.dataset.yellow || "[]"));
    m.dataset.yellow = JSON.stringify(yellowList);
    payload.push({
      type: "red",                                 // required by schema
      fx: Number(m.dataset.fx),
      fy: Number(m.dataset.fy),
      image: m.dataset.image || "cam1.jpg",
      yellow: yellowList.map(y => ({
  image: y.image || "cam2.jpg",
  fx: Number(y.fx) || 0.5,
  fy: Number(y.fy) || 0.6,
  width: Number(y.width) || 20,
  height: Number(y.height) || 40,
  rotation: Number(y.rotation) || 0,
  type: y.type || "cone", // üî• save type
})),
    });
  });

  console.log("üì§ Saving markers to server (payload):", payload);

  try {
    const res = await fetch(API("/api/markers"), {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    if (!res.ok) {
      const text = await res.text().catch(() => "");
      throw new Error(`POST /api/markers failed: ${res.status} ${res.statusText} ${text}`);
    }
    const json = await res.json();
    console.log("‚úÖ Saved markers to server:", json);
  } catch (err) {
    console.error("‚ùå Failed to save markers:", err);
    // Optional: show a quick alert so you notice immediately
    // alert("Failed to save markers: " + err.message);
  }
}

// Replace localStorage save/load with server
function saveMarkers() {
  // you can debounce here if you like, but not required
  saveMarkersToServer();
}

// Initial load from server
loadMarkersFromServer();
  </script>
</body>
</html>
